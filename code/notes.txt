Most hardware stuff seems to be working now at least in theory. SD card works in MicroPython but not yet C++, LED display is a bit flickery but I think that's a code timing issue. Next step is a full test program which does the following:
- Uses flash memory for audio storage
- Loads WAV files from SD card when needed
- Pressing buttons displays button number DONE
- Holding button shows relevant pot/CV value DONE
- Start/stop works DONE
- Sync out works DONE (but not sure what final PPQN value will be)
- Trigger outs work DONE
- Sync in flashes LED (another non-repeating timer, maybe with some debouncing)

Current issue (8/11/23), SD card errors often stop the whole program booting.

Thing I just thought of that is probably quite annoying: the characteristic sound of Drumkid is reliant on modulating the velocity of the hits, but this won't really be possible for the trigger outputs. Maybe it's okay. Or maybe the next version needs envelope outputs. Or velocity outputs plus triggers, but that's a lot of sockets.

A thought about how storage should work: there's 2MB flash on the Pico, and not much of that will be needed for anything except audio. Additionally, we shouldn't rely on the SD card for anything mission-critical - it should only be for saving/loading, not reading samples every time you power up the module. Need to figure out how to move audio files from SD to Pico flash memory. Should be able to fit maybe 20s of audio in the flash.

Currently trying to get flash read/write code working, running into issues which may be related to this: https://github.com/raspberrypi/pico-examples/issues/34 (USB serial conflict?)

Okay, progress (18/11/23): flash read/write works with code from the official example, as long as you disable interrupts before calling flash functions then restore them after, as shown here: https://www.makermatrix.com/blog/read-and-write-data-with-the-pi-pico-onboard-flash/

Right, 20/11/23, the time has come to get a proper SWD debug setup working. Pressing bootsel and reconnecting USB every time is a faff, and I'm starting to get weird errors that probably need a proper debugger, so I've ordered a Pico debug probe. Until then I'm going to stop trying to use the SD card, as this seems to be the buggiest part of the code. Probably should leave GPIO pins 0 and 1 free in the next version for UART, but that's no problem because I was going to move those buttons to shift registers anyway.

21/11/23, updated toolchain to use latest windows installer instead of previous cobbled-together setup.

A new, scattershot list of things that would be good/essential, in rough ascending order of difficulty:
- Pitch knob
- Manual tempo adjust
- Output channel toggle
- Crush effect
- Tap tempo
- Load beat
- Edit beat (step sequence)
- Save beat
- Load patch
- Save patch
- Load sample from SD DONE
- Back up all data to SD

25/11/23, debugging works with debug probe, no more pressing stupid button and reconnecting USB cable.

27/11/23, had some success debugging the issue where SD card and DAC don't play well together. Can now do some test SD card stuff (mount, open/append/close file, unmount), then do audio stuff as normal. Had to set audio DMA channel to 2, because 0 and 1 didn't work (pretty sure that SD library claims 2 DMA channels). Can't currently figure out how to tell SD library how to specify exactly which DMA channels to use, which I think is the reason I can only do SD stuff at start of code, not after audio code has begun.

28/11/23, here's the current serial output when trying to run loadSamplesFromSD() via a button:

load from SD...
Notification wait timed out in spi_transfer_wait_complete
DMA CTRL_TRIG: 0b00000000000010001000100000100001
SPI SSPCR0: 0b00000000000000000000010100000111
SPI SSPCR1: 0b00000000000000000000000000000010

*** PANIC ***

f_mount error: A hard error occurred in the low level disk I/O layer (1)

Basically fmount fails.
Okay... maybe the problem is the timers I'm using to update buttons, LEDs, etc. If I remove those timers and do everything in the main loop, SD card and audio work together. For now, I've got it working by setting a flag in the timer callback and running the SD mount function in the main loop when the flag is true.

Aaaaah that was satisfying. Was struggling to read the wav files properly because there were random bytes missing (spoiler: not actually random). Turns out I was using f_gets, which interpreted some characters as terminators or something. Switched to f_read and everything is good.

Can now load a wav sample from SD card into a variable. Next step, loading into flash?

Ugh, clap.wav has a non-44-byte header. Good to see one in the wild, though. Can use it for testing.

End of day summary because everything is slightly broken:
- Using snare.wav because it has a nice normal 44-byte header
- Trying to read 44-byte header first (for validation etc at some point)
- Then trying to read 256-byte chunks straight from SD to flash
- Trying to preview the audio data that should be in the flash but it's not right at the moment (when compared with snare.h integers)
- Next sesh, try to make this preview be correct, maybe having issues with the flash_range_program function's arguments?

29/11/23, a few useful discoveries:
- I can successfully copy samples from SD to flash
- I don't think the flash is fast enough to load samples directly (although not certain about this), so am thinking about just loading them into RAM (copying them to a buffer?)
- I've figured out the WAV header issue, although haven't code it yet. They can basically be any size, and there can even be stuff at the end of a file. This explains it well: https://stackoverflow.com/questions/19991405/how-can-i-detect-whether-a-wav-file-has-a-44-or-46-byte-header

4/12/23, thoughts:
- bit crush is maybe not needed on this version of drumkid, it just makes the interface more cluttered?
- if i'm going to have a volume knob, it needs to be a real one, not software (low volumes sound horrible because you're basically just bitcrushing)

Am now successfully copying four samples from SD and storing them consecutively in flash.

A bit like with DK1, I'm going to have to do some checks on boot to see whether the flash has valid variables, specifically the metadata in the first page.

Currently all samples are stored back to back in flash, which is efficient, but when loaded into RAM they are just put into fixed arrays, regardless of size. Should also store samples in a single block of RAM, to maximise possible cumulative sample size.

Also store other stuff in flash like tempo, current patch/beat, etc.

5/12/23

Current annoyance/problem: because writing to the flash memory requires the interrupts to be paused (probably), it causes an audible glitch if a beat is playing. Either need to only write to flash when output is silent (not great because people might power down their system with DK still running, hence no writing) or, hopefully, figure out a way to write to flash without stopping the interrupts.
Okay, looks like you only need to pause interrupts for SD card reasons, but there's still a slow blocking process maybe when writing to flash.

Oh, and also if I press the tempo change button a bunch of times, everything crashes in a way that might suggest I don't understand alarms. Nope, it's not that... basically it crashes if I the tempo gets too fast. Right, apparently everything just gets too busy - 160BPM is fine until you turn up the chance. This... is actually the biggest bug/error/whatever so far. Can the system just not keep up? Increasing sample buffer doesn't seem to help. Looks like the actual fatal error is on line 337 of the Pico SDK's time.c: assert(rt->alarm_id == id); I guess this means somehow the system is running out of timer IDs? Bit of a guess. Aha! It was the pulse timers. I had set maxPulseTimers = 10, and the system clearly needed more than that. Will rewrite now I understand alarms better. Okay I didn't rewrite it because it was boring. This paragraph is over now.

Winding up for the week maybe. Sync in now basically works, though quite a naiive implementation, not sure how other modules manage the clash between internal clock, external clock, and start/stop button. 24ppqn seems quite annoying, maybe 4 or 16 is better? Maybe needs to be a settable option, given people's differing setups.

12/12/23
Starting to look at swing implementation, read some articles (Roger Linn interview re MPC was v useful) and did some experiments in Cubase. Can definitely improve on DK1 swing implementation, which was limited because of only using 8 bits and other very-basic-microcontroller factors. Looks like maybe the least controversial implementation is to swing the off-beat 8th OR 16th notes by a percentage, e.g. 66% is triplet swing, 50% is straight, but then just don't play any subdivisions...? If you swing the off-beat 8th notes AND the off-beat 16th notes, the 2nd 8th note will no longer line up with the 3rd 16th note. ChatGPT(!) reckons that this will add to the swing feel, but I feel like this is a fudge. Cubase experiments were inconclusive. I guess the zoom control means at least that there is an option for the user not to include smaller subdivisions.

In other news, I was previously scared of multi-core coding but actually it doesn't look too bad, and it would be silly not to try it, given that I could almost double the amount of stuff I can do. Perhaps predictably, some mad stuff happens with interrupts which messes up the SD loading. Not totally sure if the problem is SD loading itself or flash stuff. Okay, I'm not going to have much more coding time in 2023 and I don't want to spend it faffing with IRQ stuff, so I'm going to restore the code to how it was.

Some issues with the new hit scheduling system - the audio is glitchy (too much calculation happening?) and some hits are missing (weird, need to investigate). Seems to work now.

Just in case I don't get to work on this for a while, here's a reminder for myself of things to work on when I'm back:
- multicore IRQ conflicts (ugh)
- swing/slop/slide implementation (a button switches between slop and slide..?) (NB slide is my word for detaching the kick/snare (at least) from the hats, see adam nealy video about quintuplet swing etc)
- reimplement start/stop button, sync in/out, and trigger out
- reimplement chance/zoom/range/midpoint

2024
Bit intimidating to come back! But making improvements. For the first time it really sounds like an improved version of Drumkid, with the hi-fi audio and new timing engine. Thoughts:
- while messing around at 250BPM, it actually sounded really cool with 64th-notes at low volume, so I might actually want to expand zoom to 128th-notes to achieve this effect with regular tempos (overall approach with any param is that turning a knob up to full should always be too far, so that the sweet spot is available)
- probably need a CV atten control for chance
- sync in and sync out are working, but could be improved. sync in is basically a tap tempo right now, and likely to be out of phase with sync input. sync out works but isn't precise, triggered at start of buffer (like all triggers, needs delay). everything just running off 1ppqn right now.

15/1/24
OKAY. Got a couple of days to work on this. Let's make a to-do list. Let's crack through some things.
- Leave sync in/out for the moment, it's complicated and will likely change during beta testing, let's just get all the buttons working
- Buttons/functions:
    - Shift DONE
    - Time signature DONE
    - Save patch
    - Load patch
    - Choose slot
    - Choose bank
    - Choose output (1/2)
    - Kick/snare/hat/other
    - Tap tempo
- Remove/reduce audible clicks (probably from retriggering a sample before it ends? some sort of quick fade needed?)
- Maybe getting some performance issues? Random clicks. Seems to be worse with kick drums..?! Maybe clicks are 0.4 seconds apart? Annoying! Okay, the clicks seem to be missing chunks of audio, possibly a whole buffer's worth, 3ms. AAH deep into Charlie-Always-Sunny conspiracy board territory, but...
    - at 110BPM (not sure if relevant), there are 4ms gaps (not exactly a buffer, but close!), at (alternately) 1.2s and 2.0s. Garbage collection..?
    - i tried loading in some longer samples to make it easier to see where the gaps were happening, and... everything crashed, in a way that felt like an SD card problem or running out of memory or something
    - maybe the upshot of all this is that i've made too much progress too quickly, and i no longer totally know what's happening with all the quite complex timing stuff. maybe it's time for a bit of a rewrite..? or at least rewrite sample.h?
    - OKAY. maybe something. i'm calculating "current time" by adding a calculated value for buffer time after each buffer loop, but if that's not exact, maybe i'm getting a buffer underrun..?
- HANDLE TRIPLETS
- handle n-tuplets?
- make zoom work properly for non-4/4 time sigs
- zoom goes weird when using tuplets
- smoothing function for pots, prevent random spikes

16/1/24
Attempting a rewrite/refactor. Everything had become a bit messy.

RIGHT. That was a very frustrating day but I think I've pretty much gotten rid of the problem. I greatly reduced the scheduler timer interval from 100ms to 20ms. I've also rewritten Sample.h, it needs the delay stuff reimplementing but it's better than before. I've also moved from floats to ints where possible. I would have liked a more concrete outcome from today, in that it would have been nice to have found a variable I could tweak to increase the severity/frequency of the clicks so I could be certain, but I do think that tweaking the relative values of schedulerInterval and scheduleAheadTime is probably the answer. I'm still getting some clicks but I'm pretty sure these are from sudden retriggers, which is a known/solvable problem. Leaving code in a decent-ish state, and tuplet stuff is really nice.

19/1/24
Random(!) idea: "chaininess" (succession? roll?) - a sort of secondary/replacement "chance" value which is only used on the next (zoom-dependent) hit after a hit (so, after a rest, the code would refer to the "chance" value, but after a hit it would instead refer to this new "chaininess" value). The upshot would be more flams, rolls, that kind of thing. So, the beat would be random but once a random hit had occurred, it could be much more likely (or indeed less likely) for another hit to occur immediately after. Might be "off" at zero, otherwise you would have to manually match it to chance to recreate current behaviour.

Finally reduced clicks by adding a tiny fade-out before a retrigger. In doing so, actually got rid of explicit "trigger" function, replaced with "waiting" and "delaySamples".

N.B. Missing first hit after changes, should be simple fix.

22/1/24
Still occasionally getting a crash from assert(rt->alarm_id == id), almost certainly because I'm trying to create hundreds of GPIO pulse timers in a stupid way. Don't do this. Whatever happens, failure modes should be "the sound goes a bit glitchy", not "the unit crashes".

Am playing with timing windows to try and make the CV control work "live", as in being able to feed in an envelope signal to the mid CV and trigger a rhythmic cascade of drums.

23/1/24
Aha! Replaced the bad timers with good timers. Got rid of messy tempo storage stuff, can just store manually with patches. Starting to sound really good.

Some clicks occasionally sneaking in.

Trying to add at least one extra level of zoom and in doing so, removing all hardcoded 16/64/whatever stuff, so that in future I can just change "maxZoom" and everything else will figure itself out. Getting a few clicks, maybe because the fade-out is now too long and doesn't get a chance to kick in before the next hit..? Not sure.

Okay, pretty sure I'm now hitting the issue where the code can't schedule multiple hits in one buffer window. Shortening the buffer almost fixes it? To be investigated. Aaaah okay it was the swing knob messing things up, it's never really set to zero so is constantly adding little perturbations which sound like buffer glitches. Need dead zones at top and bottom of all knobs (and/or probably a better CV input, not sure what's causing the wiggles, pot noise or CV noise when not plugged in).

----

While it's clear(ish) in my head, some notes about properly defining the timing/step/tuplet system. Ideally, all variables should be defined in relation to a small number of basic constants. I think all I need to define are:
QUARTER_NOTE_STEPS (32?) - the number of steps into which a quarter note is divided for the aleatoric functions (no need to sequence down to this level)
QUARTER_NOTE_SEQUENCE_STEPS_MAX (8) - max number of steps per quarter note than can be sequenced (can be less for tuplet modes)
TUPLET_MAP - coded by hand for musicality, could maybe be automated but perhaps better to just compile-time assert above values as 32 and 8. Or just don't be so precious and automate it.

The rest can then probably be calculated..?

QUARTER_NOTE_STEPS_TUPLET (8,6,5,7) - maybe could actually be calculated rather than defined
MAX_ZOOM can then be defined as 2^(QUARTER_NOTE_STEPS*4-1).

Okay, that worked pretty well. Zoom still doesn't work properly for tuplet modes, probably needs a tuplet map like the beat class.

29/1/24
Just listening to The new Smile album. Need to try some rides, crashes, chinas, longer samples, test the limits and just try something different. Just tried loading samples and it crashed. Oh, and exciting new problem, if the sample loading doesn't work but does put (bad) data into flash, you also can't reboot the unit. Workaround is to add line of code to reload (good) samples from SD before loading from flash. So how should SD loading work safely? Maybe...
- Give choice of folder to load
- Read sample metadata (and/or data itself) to check data size
- If total size too big, show error on screen, don't load data

30/1/24
A frustrating but necessary day figuring out why big samples crashed the code. Turns out I was loading samples larger than the MAX_SAMPLE_SIZE without checking, and MAX_SAMPLE_SIZE is not very big (25000 samples, about 0.5 seconds). Think I mentioned this before but I need to create a shared audio sample buffer for all four samples, to allow for one long samples and three short samples (or something). Also should be able to use different sample rates. There's enough RAM for 100,000 16-bit samples, which is 2 secs at 44kHz or 4 secs at 22kHz, allowing maybe a 3-second sample at 22kHz if the others are short. But first priority is a shared variable.

6/2/24
Not that we need more features, but... what if somehow the beat itself could evolve over time via chance? Like, start with kick snare kick snare, then if there's enough "chance", that becomes kick snare snare kick, or the kick gets shifted by an 8th note, or deleted, or another hit is added. Could even be as simple as a temporary vs permanent switch, so when a hit is generated (in normal mode), it's not just heard once, it's added to the pattern and heard on every subsequent loop. Probably mad. Just an idea.

Some random things to work on this week:
- zoom tuplet map (have maybe now solved without a map but the audio is hiccupping so should probably make a map after all)
- clamp the pot values
- user beat edit
- drop
- pitch

9/2/24
Don't think the hiccups are coming from the tuplet calculation, but from the slide control (which is maybe too niche to deserve its own knob anyway?). Need deadzones and smoothing for all pots, and maybe a better. Additionally, should maybe use clean 3.3V supply from (currently problematic) DAC power supply as the ADC/pot voltage. Oh, and I'm hitting issues with high-zoom quasi-drones (HZQDs?!) above 160BPM. Probably need to be able to queue more than one hit per buffer. Can get to ~190BPM by reducing buffer from 256 to 128 samples but that's a slight hack. And above this, the problem isn't necessarily as simple as multiple hits per buffer, as the missing hits aren't printed to serial.

Unrelatedly, "midpoint" is a stupid name, should be "velocity" or something.

12/2/24
Hit some performance issues last week, at least some of which may have stemmed from float arithmetic. Shouldn't really be using floats for much stuff in here, particularly when a 32-bit int is so huge. Today am going to try and strip out all float arithemetic which is used every single loop, top improve performance.

Have managed to implement pitch control without floats, sounds nice for sped-up samples, horrid for slowed-down, probably need to do lerping.

Did some lerping, sounds better.

13/2/24
Adding the "drop" parameter because it's really useful for live performance. (On that note, think about positioning the "range" knob directly below "mid"/"vel", because the most performable(?!) knobs should be on the top row. Drop, on DK1, mutes/unmutes groups of samples, broadly bassy stuff on left, treble on right, everything together in the middle, silence at both extremes. Like this:
0 silence
1 kick
2 kick, tom
3 kick, hat, tom
4 everything
5 hat, snare, tom
6 hat, snare
7 hat
8 silence

Seems to work fine, does the job for now, might need to be adjusted if fourth default sample is not a tom (or indeed if all samples are different).

Just did a quick check of analog reading accuracy - currently experiencing fluctuations of up to 1% (delta of 45 from a range of 4096);

I'm still grappling with annoying tiny silences when dialling zoom up to 100% (HZQD!). Current thought: get rid of all floats. Just use ints, remove all mystery. Might hit some int overflow issues, although not immediately... 32-bit int tracking current time in samples would overflow within a day. 64-bit looks good for 6 million years, which should be adequate.

Well, everything still works, but the problem is still there. Anticlimactic. Just measured missing audio, looks like 0.003s / 3ms.

AHA! Maybe have found the culprit. "mainTimerLogic"..? I just stripped some stuff out of it and maybe reduced the clicks. Let's see...

Hard to exactly replicate the glitches with mainTimerLogic. Ah, but... it could well be the scheduler callback. This seems to maybe cause more glitches with longer intervals, so more notes are stacked up waiting to be scheduled. Yes! This seems to be it. But... I'm still hitting issues as the tempo goes higher. Maybe I'm just starting to run up against the limit of how much stuff I can schedule...? Maybe I need to go dual-core? Maybe I need to ignore the glitches for now and get it to some testers while I work on the underlying engine? Time for a walk.

Had a walk. Tried adding an alarm to test for buffer underruns or whatever this stupid problem is. Can't figure it out.

16/2/24
Spent an hour or so playing with multi-core code again, but I just don't think it's worth it. I don't understand it well enough, it's going to be a faff to manage the data flow between the cores, and there are probably a lot of efficiency savings I can make in the main code. I'd overlooked how much float stuff I was doing with the zoom velocity for every single hit, so I can start there.

Okay, firstly, at higher tempos, I'm getting the "missing" error, which I'm pretty sure is to do with my bad design of the sample class, and is therefore soluble. But at lower tempos, the really annoying problem ("random" 3ms silences) can now be replicated!! If I just add some pointless extra float maths when calculating a hit's velocity, I can cause extra glitches! So I'm pretty certain I just need to speed this stuff up by using ints.

SO the plan is:
1) Rewrite sample triggering (again!) to allow plenty of pre-scheduled hits (without this, I won't be able to stress-test the more annoying glitch at higher tempos)
2) Rewrite velocity stuff without floats to (hopefully) improve performance
3) Stress test at higher speeds, potentially look at moving the scheduler out of a repeating timer callback and instead do it straight after populating the buffer in the loop, and maybe add a time limit for scheduling (the while loop is a worry), so that the failure mode is not quite scheduling all the desired hits (nice-ish audio weirdness), rather than skipping buffer updates (horrid audio weirdness).

Just getting stuck into this, making a mess but making progress. By shrinking the buffer size, I can have a quick fix to the "missing" issue and therefore find how fast I can go before the float processing causes issues. I've disabled a bunch of float stuff without actually replacing it (e.g. just fixing velocity at 100%), and that actually allowed me to go really high (1000BPM+). With very little float processing, the limit is all down to the "missing" issue, which I'm about to fix, hopefully.

N.B. To allow 32PPQN (current max zoom) at 1000BPM (an arbitrary Big Round Number but also sensible because it's a pretty high drone note, nearly top E on a mandolin), a 256-sample buffer would require ~3 hits in the queue, so for a bit of wiggle room let's say 8 hits for now for a 256-sample buffer (or 4 for 128, etc). Shouldn't take much memory so could even be more generous.

23/2/24
Today was the next stage of trying to make the code faster, with the (arbitrary) aim of 1000BPM HZQD. I think the previous slightly messy scheduling system was accidentally quite efficient, because I was previously getting up to 1000BPM+ (with a small buffer size), but the new system (where the sample objects store the scheduled hits and there is no real upper limit to queued hits) is topping out at around 180BPM. Possible culprits are very frequent 64-bit int comparisons (is it time for the next hit?), and inefficient looping through the queue when adding a new hit. Also haven't reimplemented proper velocity/pitch stuff yet, which will only add to the problem. Monday's job is to try and get back to 1000BPM+.

26/2/24
Absolute cretin, the problem was printf commands. Now back to hit queue size being the only limitation for now.

27/2/24
Today's problem: reverse sample playback. It works fine, but what you really want is to trigger reverse samples in advance, so a half-second kick sample should be triggered 500ms (~20000 samples) before it should be "heard" (the end of the sample). The problem is that the whole system is geared towards small windows and near-instant scheduling, to help with CV input responsiveness etc. If I schedule a long way ahead, I can make this work, but it's too much of a sacrifice.

Right, I figured it out to an extent, but it's a mindfuck. Rather than schedule everything really far ahead, I can just work out, for each sample, how for ahead I should be scheduling (basically the length of the sample), then convert that to a number of steps, and instead of requesting the beat hit or zoom/random hit for the current "real" step, you request the offset step. I managed to get it to work at 60BPM, but when I tried to start taking account of the tempo, it all stopped working. It's possible I'm getting integer overflows, at one point I definitely needed more than 32 bits and I don't totally understand all this stuff. Think this is maybe a good place to stop for today.

Briefly tried loading 6 samples instead of 4 and everything fell apart.

4/3/24
For some reason, when I try to move from 4 samples to 5, the code thinks the kick is too long and starts including bits of other samples (overrunning into next bit of memory). Need to go back and figure out exactly what's being stored in memory.
Okay! Solved it. I had only allocated 16 bytes of the "data" flash page for sample start points, and another 16 bytes for sample lengths. Can now successfully load 8 samples, but the tempo slows down quite a bit when you turn up the zoom. Conclusions from this:

1) Should probably stick to 4 samples
2) The system should somehow know if the calculation time is causing the tempo to slow down, at least during development

5/3/24
Added performance monitoring. System now checks once per second how many samples have been processed in that time. If much below sample rate, error is shown. With 8 samples and full zoom, the system can barely keep up even at low tempos, and is running at less than 50% speed at 1000BPM. With 4 samples, 1000BPM is still fine, major problems don't arise until nearly 3000BPM.

Now trying to make the pots/CV work a bit more nicely. There's about 1% of fluctuation in the ADC values, which is mainly an issue at the bottom (we read a lot of zeros but the noise would raise the min value above zero even with smoothing) and the top (can't even reach above 4080 or so, regardless of noise). I may add smoothing at some point, smoothing over last 10 values would improve things quite a bit (3-fold?), but might be unnecessary use of resources. Main problem is trying to implement dead zones at top and bottom of controls where we need a reliable 0% (chance, range, mid, swing, slide) or 100% (chance, zoom). Particularly difficult when combined with CV. Best approach is probably to implement dead zones selectively, not during updateAnalog(). Worst case, CV is 20 above mid, pot is 40(?) above zero, combined reading is 60, so maybe dead zone needs to be pretty big, even 100..?

Yep, that works great. Currently just applying dead zones to chance and zoom, can add others if needed, just being conservative about resources.

Started adding a special dead zone for pitch but haven't finished it (nearly dinner time).

8/3/24
Reinstated swing control, now with dead zone to stop it messing up HZQDs. Current thought for implementation: deadzoned middle point for no swing, turning left increases 8th-note swing, turning right increases 16th-note swing OR single, simple swing knob, with button setting for swing note (would also allow quarter note swing, 32nd-note swing, etc). ALSO probably want a binary option for whether to mute zoom notes beyond the swing setting.

I'm trying to fix this issue where changing the tuplets messes up the timing, but I've run out of time (which ironically is maybe what's happening in the code).

11/3/24
Okay, finally fixed the tuplet timing issue, at least enough to move on. If you keep changing the tuplet setting 10x/second or something stupid then the timing goes a bit weird/fast but that's officially an edge case now. For the record, the issue was that (say) step 19 in quintuplet mode is nearly at the end of a quarter note, while it's barely past half way in straight time - the steps have to be remapped, otherwise you end up at the wrong place within the quarter-note.

Started adding beat editing function.