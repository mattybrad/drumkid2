Most hardware stuff seems to be working now at least in theory. SD card works in MicroPython but not yet C++, LED display is a bit flickery but I think that's a code timing issue. Next step is a full test program which does the following:
- Uses flash memory for audio storage
- Loads WAV files from SD card when needed
- Pressing buttons displays button number DONE
- Holding button shows relevant pot/CV value DONE
- Start/stop works DONE
- Sync out works DONE (but not sure what final PPQN value will be)
- Trigger outs work DONE
- Sync in flashes LED (another non-repeating timer, maybe with some debouncing)

Current issue (8/11/23), SD card errors often stop the whole program booting.

Thing I just thought of that is probably quite annoying: the characteristic sound of Drumkid is reliant on modulating the velocity of the hits, but this won't really be possible for the trigger outputs. Maybe it's okay. Or maybe the next version needs envelope outputs. Or velocity outputs plus triggers, but that's a lot of sockets.

A thought about how storage should work: there's 2MB flash on the Pico, and not much of that will be needed for anything except audio. Additionally, we shouldn't rely on the SD card for anything mission-critical - it should only be for saving/loading, not reading samples every time you power up the module. Need to figure out how to move audio files from SD to Pico flash memory. Should be able to fit maybe 20s of audio in the flash.

Currently trying to get flash read/write code working, running into issues which may be related to this: https://github.com/raspberrypi/pico-examples/issues/34 (USB serial conflict?)

Okay, progress (18/11/23): flash read/write works with code from the official example, as long as you disable interrupts before calling flash functions then restore them after, as shown here: https://www.makermatrix.com/blog/read-and-write-data-with-the-pi-pico-onboard-flash/

Right, 20/11/23, the time has come to get a proper SWD debug setup working. Pressing bootsel and reconnecting USB every time is a faff, and I'm starting to get weird errors that probably need a proper debugger, so I've ordered a Pico debug probe. Until then I'm going to stop trying to use the SD card, as this seems to be the buggiest part of the code. Probably should leave GPIO pins 0 and 1 free in the next version for UART, but that's no problem because I was going to move those buttons to shift registers anyway.

21/11/23, updated toolchain to use latest windows installer instead of previous cobbled-together setup.

A new, scattershot list of things that would be good/essential, in rough ascending order of difficulty:
- Pitch knob
- Manual tempo adjust
- Output channel toggle
- Crush effect
- Tap tempo
- Load beat
- Edit beat (step sequence)
- Save beat
- Load patch
- Save patch
- Load sample from SD DONE
- Back up all data to SD

25/11/23, debugging works with debug probe, no more pressing stupid button and reconnecting USB cable.

27/11/23, had some success debugging the issue where SD card and DAC don't play well together. Can now do some test SD card stuff (mount, open/append/close file, unmount), then do audio stuff as normal. Had to set audio DMA channel to 2, because 0 and 1 didn't work (pretty sure that SD library claims 2 DMA channels). Can't currently figure out how to tell SD library how to specify exactly which DMA channels to use, which I think is the reason I can only do SD stuff at start of code, not after audio code has begun.

28/11/23, here's the current serial output when trying to run loadSamplesFromSD() via a button:

load from SD...
Notification wait timed out in spi_transfer_wait_complete
DMA CTRL_TRIG: 0b00000000000010001000100000100001
SPI SSPCR0: 0b00000000000000000000010100000111
SPI SSPCR1: 0b00000000000000000000000000000010

*** PANIC ***

f_mount error: A hard error occurred in the low level disk I/O layer (1)

Basically fmount fails.
Okay... maybe the problem is the timers I'm using to update buttons, LEDs, etc. If I remove those timers and do everything in the main loop, SD card and audio work together. For now, I've got it working by setting a flag in the timer callback and running the SD mount function in the main loop when the flag is true.

Aaaaah that was satisfying. Was struggling to read the wav files properly because there were random bytes missing (spoiler: not actually random). Turns out I was using f_gets, which interpreted some characters as terminators or something. Switched to f_read and everything is good.

Can now load a wav sample from SD card into a variable. Next step, loading into flash?

Ugh, clap.wav has a non-44-byte header. Good to see one in the wild, though. Can use it for testing.

End of day summary because everything is slightly broken:
- Using snare.wav because it has a nice normal 44-byte header
- Trying to read 44-byte header first (for validation etc at some point)
- Then trying to read 256-byte chunks straight from SD to flash
- Trying to preview the audio data that should be in the flash but it's not right at the moment (when compared with snare.h integers)
- Next sesh, try to make this preview be correct, maybe having issues with the flash_range_program function's arguments?

29/11/23, a few useful discoveries:
- I can successfully copy samples from SD to flash
- I don't think the flash is fast enough to load samples directly (although not certain about this), so am thinking about just loading them into RAM (copying them to a buffer?)
- I've figured out the WAV header issue, although haven't code it yet. They can basically be any size, and there can even be stuff at the end of a file. This explains it well: https://stackoverflow.com/questions/19991405/how-can-i-detect-whether-a-wav-file-has-a-44-or-46-byte-header

4/12/23, thoughts:
- bit crush is maybe not needed on this version of drumkid, it just makes the interface more cluttered?
- if i'm going to have a volume knob, it needs to be a real one, not software (low volumes sound horrible because you're basically just bitcrushing)

Am now successfully copying four samples from SD and storing them consecutively in flash.

A bit like with DK1, I'm going to have to do some checks on boot to see whether the flash has valid variables, specifically the metadata in the first page.

Currently all samples are stored back to back in flash, which is efficient, but when loaded into RAM they are just put into fixed arrays, regardless of size. Should also store samples in a single block of RAM, to maximise possible cumulative sample size.

Also store other stuff in flash like tempo, current patch/beat, etc.

5/12/23

Current annoyance/problem: because writing to the flash memory requires the interrupts to be paused (probably), it causes an audible glitch if a beat is playing. Either need to only write to flash when output is silent (not great because people might power down their system with DK still running, hence no writing) or, hopefully, figure out a way to write to flash without stopping the interrupts.
Okay, looks like you only need to pause interrupts for SD card reasons, but there's still a slow blocking process maybe when writing to flash.

Oh, and also if I press the tempo change button a bunch of times, everything crashes in a way that might suggest I don't understand alarms. Nope, it's not that... basically it crashes if I the tempo gets too fast. Right, apparently everything just gets too busy - 160BPM is fine until you turn up the chance. This... is actually the biggest bug/error/whatever so far. Can the system just not keep up? Increasing sample buffer doesn't seem to help. Looks like the actual fatal error is on line 337 of the Pico SDK's time.c: assert(rt->alarm_id == id); I guess this means somehow the system is running out of timer IDs? Bit of a guess. Aha! It was the pulse timers. I had set maxPulseTimers = 10, and the system clearly needed more than that. Will rewrite now I understand alarms better. Okay I didn't rewrite it because it was boring. This paragraph is over now.

Winding up for the week maybe. Sync in now basically works, though quite a naiive implementation, not sure how other modules manage the clash between internal clock, external clock, and start/stop button. 24ppqn seems quite annoying, maybe 4 or 16 is better? Maybe needs to be a settable option, given people's differing setups.

12/12/23
Starting to look at swing implementation, read some articles (Roger Linn interview re MPC was v useful) and did some experiments in Cubase. Can definitely improve on DK1 swing implementation, which was limited because of only using 8 bits and other very-basic-microcontroller factors. Looks like maybe the least controversial implementation is to swing the off-beat 8th OR 16th notes by a percentage, e.g. 66% is triplet swing, 50% is straight, but then just don't play any subdivisions...? If you swing the off-beat 8th notes AND the off-beat 16th notes, the 2nd 8th note will no longer line up with the 3rd 16th note. ChatGPT(!) reckons that this will add to the swing feel, but I feel like this is a fudge. Cubase experiments were inconclusive. I guess the zoom control means at least that there is an option for the user not to include smaller subdivisions.

In other news, I was previously scared of multi-core coding but actually it doesn't look too bad, and it would be silly not to try it, given that I could almost double the amount of stuff I can do. Perhaps predictably, some mad stuff happens with interrupts which messes up the SD loading. Not totally sure if the problem is SD loading itself or flash stuff. Okay, I'm not going to have much more coding time in 2023 and I don't want to spend it faffing with IRQ stuff, so I'm going to restore the code to how it was.

Some issues with the new hit scheduling system - the audio is glitchy (too much calculation happening?) and some hits are missing (weird, need to investigate). Seems to work now.

Just in case I don't get to work on this for a while, here's a reminder for myself of things to work on when I'm back:
- multicore IRQ conflicts (ugh)
- swing/slop/slide implementation (a button switches between slop and slide..?) (NB slide is my word for detaching the kick/snare (at least) from the hats, see adam nealy video about quintuplet swing etc)
- reimplement start/stop button, sync in/out, and trigger out
- reimplement chance/zoom/range/midpoint

2024
Bit intimidating to come back! But making improvements. For the first time it really sounds like an improved version of Drumkid, with the hi-fi audio and new timing engine. Thoughts:
- while messing around at 250BPM, it actually sounded really cool with 64th-notes at low volume, so I might actually want to expand zoom to 128th-notes to achieve this effect with regular tempos (overall approach with any param is that turning a knob up to full should always be too far, so that the sweet spot is available)
- probably need a CV atten control for chance
- sync in and sync out are working, but could be improved. sync in is basically a tap tempo right now, and likely to be out of phase with sync input. sync out works but isn't precise, triggered at start of buffer (like all triggers, needs delay). everything just running off 1ppqn right now.

15/1/24
OKAY. Got a couple of days to work on this. Let's make a to-do list. Let's crack through some things.
- Leave sync in/out for the moment, it's complicated and will likely change during beta testing, let's just get all the buttons working
- Buttons/functions:
    - Shift DONE
    - Time signature DONE
    - Save patch
    - Load patch
    - Choose slot
    - Choose bank
    - Choose output (1/2)
    - Kick/snare/hat/other
    - Tap tempo
- Remove/reduce audible clicks (probably from retriggering a sample before it ends? some sort of quick fade needed?)
- Maybe getting some performance issues? Random clicks. Seems to be worse with kick drums..?! Maybe clicks are 0.4 seconds apart? Annoying! Okay, the clicks seem to be missing chunks of audio, possibly a whole buffer's worth, 3ms. AAH deep into Charlie-Always-Sunny conspiracy board territory, but...
    - at 110BPM (not sure if relevant), there are 4ms gaps (not exactly a buffer, but close!), at (alternately) 1.2s and 2.0s. Garbage collection..?
    - i tried loading in some longer samples to make it easier to see where the gaps were happening, and... everything crashed, in a way that felt like an SD card problem or running out of memory or something
    - maybe the upshot of all this is that i've made too much progress too quickly, and i no longer totally know what's happening with all the quite complex timing stuff. maybe it's time for a bit of a rewrite..? or at least rewrite sample.h?
    - OKAY. maybe something. i'm calculating "current time" by adding a calculated value for buffer time after each buffer loop, but if that's not exact, maybe i'm getting a buffer underrun..?
- HANDLE TRIPLETS
- handle n-tuplets?
- make zoom work properly for non-4/4 time sigs
- zoom goes weird when using tuplets
- smoothing function for pots, prevent random spikes

16/1/24
Attempting a rewrite/refactor. Everything had become a bit messy.

RIGHT. That was a very frustrating day but I think I've pretty much gotten rid of the problem. I greatly reduced the scheduler timer interval from 100ms to 20ms. I've also rewritten Sample.h, it needs the delay stuff reimplementing but it's better than before. I've also moved from floats to ints where possible. I would have liked a more concrete outcome from today, in that it would have been nice to have found a variable I could tweak to increase the severity/frequency of the clicks so I could be certain, but I do think that tweaking the relative values of schedulerInterval and scheduleAheadTime is probably the answer. I'm still getting some clicks but I'm pretty sure these are from sudden retriggers, which is a known/solvable problem. Leaving code in a decent-ish state, and tuplet stuff is really nice.

19/1/24
Random(!) idea: "chaininess" (succession? roll?) - a sort of secondary/replacement "chance" value which is only used on the next (zoom-dependent) hit after a hit (so, after a rest, the code would refer to the "chance" value, but after a hit it would instead refer to this new "chaininess" value). The upshot would be more flams, rolls, that kind of thing. So, the beat would be random but once a random hit had occurred, it could be much more likely (or indeed less likely) for another hit to occur immediately after. Might be "off" at zero, otherwise you would have to manually match it to chance to recreate current behaviour.

Finally reduced clicks by adding a tiny fade-out before a retrigger. In doing so, actually got rid of explicit "trigger" function, replaced with "waiting" and "delaySamples".

N.B. Missing first hit after changes, should be simple fix.

22/1/24
Still occasionally getting a crash from assert(rt->alarm_id == id), almost certainly because I'm trying to create hundreds of GPIO pulse timers in a stupid way. Don't do this. Whatever happens, failure modes should be "the sound goes a bit glitchy", not "the unit crashes".

Am playing with timing windows to try and make the CV control work "live", as in being able to feed in an envelope signal to the mid CV and trigger a rhythmic cascade of drums.

23/1/24
Aha! Replaced the bad timers with good timers. Got rid of messy tempo storage stuff, can just store manually with patches. Starting to sound really good.

Some clicks occasionally sneaking in.

Trying to add at least one extra level of zoom and in doing so, removing all hardcoded 16/64/whatever stuff, so that in future I can just change "maxZoom" and everything else will figure itself out. Getting a few clicks, maybe because the fade-out is now too long and doesn't get a chance to kick in before the next hit..? Not sure.

Okay, pretty sure I'm now hitting the issue where the code can't schedule multiple hits in one buffer window. Shortening the buffer almost fixes it? To be investigated. Aaaah okay it was the swing knob messing things up, it's never really set to zero so is constantly adding little perturbations which sound like buffer glitches. Need dead zones at top and bottom of all knobs (and/or probably a better CV input, not sure what's causing the wiggles, pot noise or CV noise when not plugged in).

----

While it's clear(ish) in my head, some notes about properly defining the timing/step/tuplet system. Ideally, all variables should be defined in relation to a small number of basic constants. I think all I need to define are:
QUARTER_NOTE_STEPS (32?) - the number of steps into which a quarter note is divided for the aleatoric functions (no need to sequence down to this level)
QUARTER_NOTE_SEQUENCE_STEPS_MAX (8) - max number of steps per quarter note than can be sequenced (can be less for tuplet modes)
TUPLET_MAP - coded by hand for musicality, could maybe be automated but perhaps better to just compile-time assert above values as 32 and 8. Or just don't be so precious and automate it.

The rest can then probably be calculated..?

QUARTER_NOTE_STEPS_TUPLET (8,6,5,7) - maybe could actually be calculated rather than defined
MAX_ZOOM can then be defined as 2^(QUARTER_NOTE_STEPS*4-1).

Okay, that worked pretty well. Zoom still doesn't work properly for tuplet modes, probably needs a tuplet map like the beat class.

29/1/24
Just listening to The new Smile album. Need to try some rides, crashes, chinas, longer samples, test the limits and just try something different. Just tried loading samples and it crashed. Oh, and exciting new problem, if the sample loading doesn't work but does put (bad) data into flash, you also can't reboot the unit. Workaround is to add line of code to reload (good) samples from SD before loading from flash. So how should SD loading work safely? Maybe...
- Give choice of folder to load
- Read sample metadata (and/or data itself) to check data size
- If total size too big, show error on screen, don't load data

30/1/24
A frustrating but necessary day figuring out why big samples crashed the code. Turns out I was loading samples larger than the MAX_SAMPLE_SIZE without checking, and MAX_SAMPLE_SIZE is not very big (25000 samples, about 0.5 seconds). Think I mentioned this before but I need to create a shared audio sample buffer for all four samples, to allow for one long samples and three short samples (or something). Also should be able to use different sample rates. There's enough RAM for 100,000 16-bit samples, which is 2 secs at 44kHz or 4 secs at 22kHz, allowing maybe a 3-second sample at 22kHz if the others are short. But first priority is a shared variable.

6/2/24
Not that we need more features, but... what if somehow the beat itself could evolve over time via chance? Like, start with kick snare kick snare, then if there's enough "chance", that becomes kick snare snare kick, or the kick gets shifted by an 8th note, or deleted, or another hit is added. Could even be as simple as a temporary vs permanent switch, so when a hit is generated (in normal mode), it's not just heard once, it's added to the pattern and heard on every subsequent loop. Probably mad. Just an idea.

Some random things to work on this week:
- zoom tuplet map (have maybe now solved without a map but the audio is hiccupping so should probably make a map after all)
- clamp the pot values
- user beat edit
- drop
- pitch

9/2/24
Don't think the hiccups are coming from the tuplet calculation, but from the slide control (which is maybe too niche to deserve its own knob anyway?). Need deadzones and smoothing for all pots, and maybe a better. Additionally, should maybe use clean 3.3V supply from (currently problematic) DAC power supply as the ADC/pot voltage. Oh, and I'm hitting issues with high-zoom quasi-drones (HZQDs?!) above 160BPM. Probably need to be able to queue more than one hit per buffer. Can get to ~190BPM by reducing buffer from 256 to 128 samples but that's a slight hack. And above this, the problem isn't necessarily as simple as multiple hits per buffer, as the missing hits aren't printed to serial.

Unrelatedly, "midpoint" is a stupid name, should be "velocity" or something.

12/2/24
Hit some performance issues last week, at least some of which may have stemmed from float arithmetic. Shouldn't really be using floats for much stuff in here, particularly when a 32-bit int is so huge. Today am going to try and strip out all float arithemetic which is used every single loop, top improve performance.

Have managed to implement pitch control without floats, sounds nice for sped-up samples, horrid for slowed-down, probably need to do lerping.

Did some lerping, sounds better.

13/2/24
Adding the "drop" parameter because it's really useful for live performance. (On that note, think about positioning the "range" knob directly below "mid"/"vel", because the most performable(?!) knobs should be on the top row. Drop, on DK1, mutes/unmutes groups of samples, broadly bassy stuff on left, treble on right, everything together in the middle, silence at both extremes. Like this:
0 silence
1 kick
2 kick, tom
3 kick, hat, tom
4 everything
5 hat, snare, tom
6 hat, snare
7 hat
8 silence

Seems to work fine, does the job for now, might need to be adjusted if fourth default sample is not a tom (or indeed if all samples are different).

Just did a quick check of analog reading accuracy - currently experiencing fluctuations of up to 1% (delta of 45 from a range of 4096);

I'm still grappling with annoying tiny silences when dialling zoom up to 100% (HZQD!). Current thought: get rid of all floats. Just use ints, remove all mystery. Might hit some int overflow issues, although not immediately... 32-bit int tracking current time in samples would overflow within a day. 64-bit looks good for 6 million years, which should be adequate.

Well, everything still works, but the problem is still there. Anticlimactic. Just measured missing audio, looks like 0.003s / 3ms.

AHA! Maybe have found the culprit. "mainTimerLogic"..? I just stripped some stuff out of it and maybe reduced the clicks. Let's see...

Hard to exactly replicate the glitches with mainTimerLogic. Ah, but... it could well be the scheduler callback. This seems to maybe cause more glitches with longer intervals, so more notes are stacked up waiting to be scheduled. Yes! This seems to be it. But... I'm still hitting issues as the tempo goes higher. Maybe I'm just starting to run up against the limit of how much stuff I can schedule...? Maybe I need to go dual-core? Maybe I need to ignore the glitches for now and get it to some testers while I work on the underlying engine? Time for a walk.

Had a walk. Tried adding an alarm to test for buffer underruns or whatever this stupid problem is. Can't figure it out.

16/2/24
Spent an hour or so playing with multi-core code again, but I just don't think it's worth it. I don't understand it well enough, it's going to be a faff to manage the data flow between the cores, and there are probably a lot of efficiency savings I can make in the main code. I'd overlooked how much float stuff I was doing with the zoom velocity for every single hit, so I can start there.

Okay, firstly, at higher tempos, I'm getting the "missing" error, which I'm pretty sure is to do with my bad design of the sample class, and is therefore soluble. But at lower tempos, the really annoying problem ("random" 3ms silences) can now be replicated!! If I just add some pointless extra float maths when calculating a hit's velocity, I can cause extra glitches! So I'm pretty certain I just need to speed this stuff up by using ints.

SO the plan is:
1) Rewrite sample triggering (again!) to allow plenty of pre-scheduled hits (without this, I won't be able to stress-test the more annoying glitch at higher tempos)
2) Rewrite velocity stuff without floats to (hopefully) improve performance
3) Stress test at higher speeds, potentially look at moving the scheduler out of a repeating timer callback and instead do it straight after populating the buffer in the loop, and maybe add a time limit for scheduling (the while loop is a worry), so that the failure mode is not quite scheduling all the desired hits (nice-ish audio weirdness), rather than skipping buffer updates (horrid audio weirdness).

Just getting stuck into this, making a mess but making progress. By shrinking the buffer size, I can have a quick fix to the "missing" issue and therefore find how fast I can go before the float processing causes issues. I've disabled a bunch of float stuff without actually replacing it (e.g. just fixing velocity at 100%), and that actually allowed me to go really high (1000BPM+). With very little float processing, the limit is all down to the "missing" issue, which I'm about to fix, hopefully.

N.B. To allow 32PPQN (current max zoom) at 1000BPM (an arbitrary Big Round Number but also sensible because it's a pretty high drone note, nearly top E on a mandolin), a 256-sample buffer would require ~3 hits in the queue, so for a bit of wiggle room let's say 8 hits for now for a 256-sample buffer (or 4 for 128, etc). Shouldn't take much memory so could even be more generous.

23/2/24
Today was the next stage of trying to make the code faster, with the (arbitrary) aim of 1000BPM HZQD. I think the previous slightly messy scheduling system was accidentally quite efficient, because I was previously getting up to 1000BPM+ (with a small buffer size), but the new system (where the sample objects store the scheduled hits and there is no real upper limit to queued hits) is topping out at around 180BPM. Possible culprits are very frequent 64-bit int comparisons (is it time for the next hit?), and inefficient looping through the queue when adding a new hit. Also haven't reimplemented proper velocity/pitch stuff yet, which will only add to the problem. Monday's job is to try and get back to 1000BPM+.

26/2/24
Absolute cretin, the problem was printf commands. Now back to hit queue size being the only limitation for now.

27/2/24
Today's problem: reverse sample playback. It works fine, but what you really want is to trigger reverse samples in advance, so a half-second kick sample should be triggered 500ms (~20000 samples) before it should be "heard" (the end of the sample). The problem is that the whole system is geared towards small windows and near-instant scheduling, to help with CV input responsiveness etc. If I schedule a long way ahead, I can make this work, but it's too much of a sacrifice.

Right, I figured it out to an extent, but it's a mindfuck. Rather than schedule everything really far ahead, I can just work out, for each sample, how for ahead I should be scheduling (basically the length of the sample), then convert that to a number of steps, and instead of requesting the beat hit or zoom/random hit for the current "real" step, you request the offset step. I managed to get it to work at 60BPM, but when I tried to start taking account of the tempo, it all stopped working. It's possible I'm getting integer overflows, at one point I definitely needed more than 32 bits and I don't totally understand all this stuff. Think this is maybe a good place to stop for today.

Briefly tried loading 6 samples instead of 4 and everything fell apart.

4/3/24
For some reason, when I try to move from 4 samples to 5, the code thinks the kick is too long and starts including bits of other samples (overrunning into next bit of memory). Need to go back and figure out exactly what's being stored in memory.
Okay! Solved it. I had only allocated 16 bytes of the "data" flash page for sample start points, and another 16 bytes for sample lengths. Can now successfully load 8 samples, but the tempo slows down quite a bit when you turn up the zoom. Conclusions from this:

1) Should probably stick to 4 samples
2) The system should somehow know if the calculation time is causing the tempo to slow down, at least during development

5/3/24
Added performance monitoring. System now checks once per second how many samples have been processed in that time. If much below sample rate, error is shown. With 8 samples and full zoom, the system can barely keep up even at low tempos, and is running at less than 50% speed at 1000BPM. With 4 samples, 1000BPM is still fine, major problems don't arise until nearly 3000BPM.

Now trying to make the pots/CV work a bit more nicely. There's about 1% of fluctuation in the ADC values, which is mainly an issue at the bottom (we read a lot of zeros but the noise would raise the min value above zero even with smoothing) and the top (can't even reach above 4080 or so, regardless of noise). I may add smoothing at some point, smoothing over last 10 values would improve things quite a bit (3-fold?), but might be unnecessary use of resources. Main problem is trying to implement dead zones at top and bottom of controls where we need a reliable 0% (chance, range, mid, swing, slide) or 100% (chance, zoom). Particularly difficult when combined with CV. Best approach is probably to implement dead zones selectively, not during updateAnalog(). Worst case, CV is 20 above mid, pot is 40(?) above zero, combined reading is 60, so maybe dead zone needs to be pretty big, even 100..?

Yep, that works great. Currently just applying dead zones to chance and zoom, can add others if needed, just being conservative about resources.

Started adding a special dead zone for pitch but haven't finished it (nearly dinner time).

8/3/24
Reinstated swing control, now with dead zone to stop it messing up HZQDs. Current thought for implementation: deadzoned middle point for no swing, turning left increases 8th-note swing, turning right increases 16th-note swing OR single, simple swing knob, with button setting for swing note (would also allow quarter note swing, 32nd-note swing, etc). ALSO probably want a binary option for whether to mute zoom notes beyond the swing setting.

I'm trying to fix this issue where changing the tuplets messes up the timing, but I've run out of time (which ironically is maybe what's happening in the code).

11/3/24
Okay, finally fixed the tuplet timing issue, at least enough to move on. If you keep changing the tuplet setting 10x/second or something stupid then the timing goes a bit weird/fast but that's officially an edge case now. For the record, the issue was that (say) step 19 in quintuplet mode is nearly at the end of a quarter note, while it's barely past half way in straight time - the steps have to be remapped, otherwise you end up at the wrong place within the quarter-note.

Started adding beat editing function.

12/3/24
Let's set out exactly what goes into the flash memory and where. There are 2MB of flash, and I'm avoid the first 1MB, which should be plenty of room for the code. For future reference, can run this command to check how big the code is:

objdump --all code/build/drumkid.elf | grep flash_binary_end

This gives a hex number (e.g. 100657ac today). Basically get rid of the 100 part (subtract 10000000 hex, aka XIP_BASE) and convert to decimal to see code size, e.g. 657ac = 415660 = ~0.5MB. Could almost certainly start flash storage at, say, 0.6MB now. Audio storage is actually limited by RAM rather than flash - can't fit more than 100k samples (200kB) in RAM, aka about 50 sectors.

Flash memory is divided into pages (256 bytes) and sectors (4096 bytes, 16 pages). You must erase before you write, and you can only erase a whole sector, so data should be grouped by sector. Current schema, leaving gaps because we're not too pushed for space:

Sector  Data
0       Data check number, sample lengths and start points
4       Preset beats (128 * 32-byte beats)
8       User beats (128 * 32-byte beats)
128     Audio data (space for ~6 seconds, RAM limits us to ~2 seconds)

That all worked! Good! Now for something completely different.

Am rethinking clock input, which I was doing in a stupid way before. I'm going to support a few different PPQN values, starting with 4 and 24 (both common, apparently). Either way (and especially for 4PPQN), I'm going to need to implement an internal clock divider. Okay, this is doable. As long as you're not too fussy about the very first 16th-note having all its subdivisions available (because there's not enough info to divide the clock until we've had two pulses), this should be fine. And we may end up with a reset/start trigger input, too, if that's a standard thing.

14/3/24
My thinking is becoming clearer. It's good to support multiple input PPQN values because people's setups are all different. Some people might want 4PPQN, or even 1PPQN, and that's fine because it's nice and simple to work with for the user, but probably won't do great with tempo changes (or instant starts), so I should probably offer all vaguely sensible values from 1 to, maybe, 96? And I think it's fine to have a "recommended" value, or different ones for different uses.

To do tomorrow: make DK run from 1PPQN, 4PPQN, and 96PPQN (LFO).

15/3/24
Step one today, try to go back to having the scheduler function run on a repeating timer, because that's closer to the behaviour needed with clock input. Well, that worked. Having a few issues now with either double hits (when slowing down tempo) or no hits (when speeding up). Need some sort of guarantee of which step has been heard.

19/3/24
Oops, a bunch of stuff happened which I didn't write down. Fixed most of the issues with external clock, working pretty nicely now. Have moved from using tempo directly in timing calculations to using "stepTime", measured in samples, although this is not really accurate enough, because at high tempos, the stepTime for 1000BPM and 1001BPM, say, is identical. Probably a niche issue but will become important if I pursue tempo CV for pitch control over HZQDs.

Think I made a mistake writing the code for external clock timing - it doesn't work easily with tuplets.

26/3/24
Doing some annoying SD card stuff, figuring out how to alphabetise folders, prevent crashes, etc. Figured out how to do card detect with sd_test_com (only after sd_init_driver).

"Cluster" works okay. Might be interesting. Might need tweaking. Certainly needs to be optional.

2/4/24
Added random drop, does a decent job. Removed zoom velocity gradient, temporarily for now but not sure it should even be an option to add it back in, it feels cleaner this way.

8/4/24
Going somewhat insane tracking down performance issues (glitches). Found one satisfying one: turns out that max "chance" didn't guarantee 100% probability, edge case of rand()%4096 = 4095 would fail to trigger a hit, hence cause an audible glitch. 
However, I'm still getting some glitches (buffer underruns?), especially at very high tempos. Might be time to be sensible and just accept that maybe 500BPM is a good max, or 1000BPM with occasional glitches is okay if it's a known thing.

9/4/24
Went some way down the rabbit hole of controlling the tempo melodically with a volt/octave CV signal. Think this is probably a step too far for a few reasons:
- Already starting to hit some performance issues before this
- Voltage readings not currently stable enough for smooth notes
- Tuning issues arising from measuring time in samples throughout the code (big adjustment to change this now)
- Probably a very niche feature anyway

If I do choose to come back to the feature, here are some thoughts:
- Could maybe use a lookup table to speed up calculation
- Analog readings might be better with next PCB
- Could average last few analog readings

10/4/24
There are some settings which should be stored in the flash automatically because it's likely that users are just setting things for their system and then leaving them alone. Examples:
- PPQN values (in/out)
- Clock source (internal/external)

Found some cheap slim knobs: https://www.ebay.co.uk/itm/385602579126

Some notes about design before the next PCB:
- Assume slim knobs, approx 11mm diameter
- Don't both with big chunky buttons, smaller ones are more responsive and cheaper and could actually have some extra buttons

15/4/24
Turns out cheap knobs are 270-degree, not 180, but also seems like that's maybe standard for these slim knobs, and they are cheap, so I'm just going to rotate the pots on the next PCB (carefully!).

Fine tuning the PCB design, will probably move to 11mm standoffs on the top layer and no standoffs on the bottom. Need to source longer tactile buttons, maybe TS02-66-140-BK-160-LCR-D (or SCR-D? check) or similar, 14mm above PCB, hence about 1.4mm proud of top panel.

18/4/24
Making a quick list of things that I know need changing for the next PCB:
BOTTOM PCB:
- holes not needed
- PCB can be smaller without holes (if needed)
- breakout pins for Pico
- AP7333 pinout has been wrong twice now!
- Supply ADC VREF from AP7333 via jumper
- Serial debug pins
- Remove tap tempo and start/stop buttons (all buttons now 6mm not 12mm)
TOP PCB
- Remove tap tempo and start/stop buttons
- Add more buttons and another shift reg (probably)
- Pots rotated 90 degrees LEFT (CCW)
- Reduce 7-seg resistor values
PANEL
- Pots rotated 90 degrees LEFT (CCW)
- Keep copper intact (looks better)

17/5/24
Back in the game after time off! Red film ordered for LED display. Display will be mounted below/flush with top surface, not proud. Keep same cutout in front panel for now, probably just solder in place with some 3mm shims then remove.

Lengthened sync/trigger output pulse to 15ms after realising it wasn't always triggering the Division 6 Dual Mini Sequencer clock input. This should be adjustable in settings I guess.

Improved pitch knob. 12 o'clock now corresponds to 1x playback speed, with a deadzone. Weirdly, it turns out the pots don't seem to be very symmetrical, meaning they seem to turn further CW than they do CCW, which means the 12 o'clock point is not 2048 in the code, annoyingly. If this is the same for every pot, I can just tweak the centre value in the code where 12 o'clock matters. If it's a random variation between pots, I might just have to increase the deadzones. The datasheet suggests a +/- 5 deg range (i.e. 10 deg total). Looking at the knobs in a row now, it does seem like there is variation. Could be a soldering issue..? I guess I'll just increase/check the deadzones.

Am also considering a calibration function, mainly for CV inputs but could also work for knobs in their 12 o'clock positions.

First stab at "magnet" or whatever I wanted to call it - decreasing hit probability for weirder notes (128th notes etc) while still allowing 100% probability with chance knob at full. Next step, try making this magnet effect knob-controlled, at least to see if it's helpful.

22/5/24
Good progress on the magnet paramater. Basically raising the chance param value to a higher power as stepVal increases seems to feel good. Current issue is how exactly to fade from zero magnet to half to full. At the moment the transition is quite sudden, it either feels fully random or fully biased. Might be overkill, but thinking of this:
m = 0: fully random, not dependent on stepVal
m = 0.5: exponent is proportional to stepVal
m = 1: only quarter notes (adheres to the philosophy of full max value being properly extreme)
Also probably need to be careful with the transition between these functions/lookups.

There's a conflict of two behaviours with the above idea. At 100% chance, should the magnet "win" and only quarter notes be heard? Or should 100% chance mean exactly that, and overcome the magnet? Feels like the latter makes more sense, because if you wanted constant quarter notes, you could just reduce the zoom anyway. 

Tried to implement this 5 minutes before I have to leave, which was silly, as I've messed it up.

24/5/24
Magnet control good enough for now.

25/6/24
Have implemented a wear levelling algorithm to allow all settings to be saved regularly without (hopefully) wearing out the flash memory. Currently am saving all settings every time the beat stops. This should change, at the very least, to every time the beat stops AND there are no settings to change. Should also probably save periodically if settings are changed when beat is not playing..? Also currently am writing to a whole new sector each time. Could potentially keep writing to sequential pages for a 16x improvement in wear levelling.

28/6/24
Have spent the morning thinking about whether I can improve the ADC readings. The datasheet for the Pico admits that the built-in ADC reference is noisy, and suggests a 3V (not 3.3V) shunt (e.g. LM4040). To make this work with the current Drumkid circuit, I would need to ensure the LM4040 could be used as the voltage source for 12 pots (not certain, ChatGPT recommends buffering the voltage with an op-amp), and I'd need to tweak the CV input resistor values - the LM4040 definitely can't power the MCP6002's, so I'd have to keep using 3.3V, which would then be clamping the output at 3.3V instead of 3V. I could change the resistor values, so that instead of reading -5V to 5V and clamping anything outside that range, I could (for instance) read -12V to 12V as 0V to 3V with no clamping, or maybe clamp values below 0V and allow a maximum output of 3V (for -12V input, it's inverting), but this would be a faff, would roughly halve the resolution (probably not a problem), and would require some careful coding/calibration. Overall I feel like the risk of getting a dud PCB because I'm changing so much stuff is probably not worth the benefit of cleaner ADC, because I'm really not feeling much of an issue with the pots or CV inputs during testing. For a future version, I could do something like this (I've simulated the op-amp changes in LTSpice). 

22/7/24
PCB 2.03 is here and working well. Some minor issues so far:
- Tactile button holes are slightly too big
- Knobs maybe feel a bit cheap? Maybe don't need them to be so small if not adding scale markings. Maybe stop being so wedded to the same pots for every project, use similar to Doepfer?
- Display height/opening not necessarily perfect yet
- Add + markings to the LEDs
- Add soldering order? TOP: display header, buttons, jacks, SD, LEDs, pots, rear headers. BOTTOM: diode, pico headers, euro power, dac jumper, little cap, inductor, big cap

23/7/24
Just fixed an issue where the sync output didn't fire at the right times in tuplet mode, and it got me thinking about how I've approached the main timing system in a slightly stupid way. When the tuplet mode changes, I change the value of a step, and the whole drum machine is suddenly operating in "quintuplet mode" or whatever. It works, but it would have made way more sense to just keep a steady clock going at 32PPQN or whatever and then derive everything from that. How about 3360PPQN? That's divisible by all the PPQN values that I use in tuplet modes (32, 24, 15, 28). I reckon it's too late right now to change it (I'll go insane), but a good idea for the future.

If I was redesigning everything from scratch, I'd also have finer-grained timing, allow for fractional tempos etc.

25/7/24
Tried setting GPIO 23 to high. Seemed to improve noise issues so will keep that in.

26/7/24
Been soldering up a second V2.03. Tried naiively drag-and-dropping the UF2 file via USB to see if it was as simple as that. Got an error light which went away (mysteriously?) when I plugged in the debugger. Or maybe it went away the first time I rebooted the unit AFTER having attempted an SD card load. Either way, need to think about the first boot process.

Some thoughts about manual soldering vs JLCPCB. Drumkid V1 had SMD components done by JLCPCB, through-hole by me, partly because there was no front panel to hide slightly wonky machine soldering (after I tried switching the buttons to SMD) but I don't want to spend my life soldering with this version. Have been checking out the wave soldering option. Can't quite work out how it works, whether I can have components wave-soldered on two sides, etc. Regardless, I think I'd have to solder a few of the less common (vertical jacks) or more fiddly (LED with holder) components, but would be nice to, say, halve the amount of soldering I'd need to do. Buttons and headers would be a good place to start, maybe also pots.

Just had a play with two V2.03 units. Really not a fan of the external clock mode - not very steady at all.

29/7/24
Tried connecting two DK2.03 modules together via clock in/out. Definitely not very nice. Think the problem is probably the output pulse rather than input polling, because it's polling at 10kHz and sounds fine when ramping tempo up/down via a square-wave oscillator. Looks like I've done the output in a stupid way in the code. The audio buffer loop thing is not guaranteed to happen at a particular time (quick testing shows intervals seem to range from ~0.2ms to ~4ms!) so there should be no precise timing stuff in there. This also probably explains why live edit mode is borked.

Hard to know how to fix this without a lot of rewriting. I feel like I've done something pretty majorly wrong with the timing in the code, but somehow it still works almost perfectly apart from this.

19/8/24
After a lot of thinking and a lot of messing about, I decided it was time to partially rewrite the Drumkid 2 code, because there were too many issues with timing. External clock mode was really janky, and the code for tuplet stuff was all pretty horrible.
My new way of handling sync input is to just schedule the hits as soon as a pulse is received, and not use the repeating timer thing at all in this mode. Will have to do some sort of clock-dividing stuff for lower PPQN input values.
I also think I'm going to rewrite the "beat" object so that instead of a binary grid of finite resolution, it's more like a list of events. This should allow better tuplet behaviour. Not a final decision though.

23/8/24
Right, I'm finally quite happy with the timing engine again. While it's fresh in my head, I'm going to try to explain what's going on. Today, I've been sticking with 32 PPQN so I'll describe everything in those terms for now. I've unified internal and external clock modes so they basically work the same: every time a pulse is received (whether from the clock input GPIO or from a repeating timer in the code), the program calculates when the next pulse should happen (i.e. the time since the last pulse) and then calculates the timing of any interim events that should happen. With an input pulse of 1PPQN, this means that 32 evenly spaced timings are calculated. A series of 32 alarms are set off, each slightly before the anticipated hit. The hit time is precalculated using DAC time. If there is drift between DAC time and normal time detected at the next pulse, some subtle correction is applied (work in progress).

5/9/24
RIGHT. I've been through a lot of changes in the last week or so. The 32-alarms thing was good until I started trying to add tuplets, then it got weird and bad. Then I went back to the regular callback thing but then I realised, this is silly. The DAC *should* update regularly, it shouldn't be unpredictable, and if I can make it predictable, I'll have a predictable chunk of time to do all my calculations in. And... yes. All of this stupid dancing around the DAC's weirdness was probably unnecessary. Turns out, if you use a buffer size smaller than 256 samples, you get the weird behaviour I've been working around (one longer gap then several tiny gaps). But for 256, 512, etc, it's just nice and predictable. So let's start again(!) with that limitation. I'd rather not have the 6ms latency thing to deal with, but hopefully it's not too bad. First indications are that this is the right approach and things are working well. This is maybe the first time I've felt in control of the DAC's audio since the start. It's kind of mad that I managed to make everything work as well as it did before.

6/9/24
Yep, this is all working great. Way easier to calculate sync in pulse, PPQN stuff, all of that. HZQD seems stable once you pick a sensible PPQN. 24PPQN is suddenly no biggy. And I should be able to revert back to a fully DAC-timing-based system for internal clock, no faffing with pulses. Plus I can presumably now monitor performance issues really easily? I can record the time it takes to do all the stuff before I update the DAC, and if it's anywhere near 6ms then I've got issues. MONDAY: tidy everything up, remove old code, check variable names make sense, add comments, then add internal clock mode etc. After that, bring back shift register stuff to check that the timers don't mess with the DAC (maybe try and run more stuff directly after the DAC has updated, keep everything aligned on a 6ms cycle).